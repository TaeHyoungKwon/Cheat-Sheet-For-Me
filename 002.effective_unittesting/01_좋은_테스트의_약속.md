# 좋은 테스트의 약속



## 1.1 더 좋은 테스트를 작성하기 위한 현황 점검

*   테스트 선행 방식 
    *   자동화된 테스트를 단순한 오류 예방 목적
    *   코딩 전에 그 코드에 기대하는 동작을 정의하는 설계 보조 수단으로까지 활용
        *   구현까지 다 끝나야 검증을 시작하는 것이 아닌, 애초에 설계부터 검증하고 들어감
*   테스트를 더 잘 작성해야 한다고 강조하는 이유?
    1.  실수를 바로 잡아준다.
    2.  실사용에 적합한 설계를 끌어내준다.
    3.  원하는 동작을 명확히 알려주고, 군더더기를 없애 준다.
        *   실패할 테스트를 거쳐간 코드는 분명 필요한 기능을 모두 담고 있으면서도 이전 방식으로 작성한 코드보다 훨씬 간결
    4.  테스트를 작성해서 얻게되는 가장 큰 수확은 테스트 자체가 아니다. 작성 과정에서 얻는 꺠달음
    5.  테스트를 설계 도구로 인식하는 순간 품질 고지를 뛰어넘어 설계 고지에 도달하는 길이 열리게 된다.
*   테스트 품질을 등한시 하면 어떤 일이 벌어질까?
*   100% 의 코드 커버리지 달성이 중요하지 않다.
    *   테스트의 가치는 테스트가 확인하지 ㅁ소한 코드가 어던 것인가와 테스트가 프로그래밍 실수를 얼마나 정확하게 잡아내는가에 좌우됨
    *   100%를 달성했다고 결함이 없다고 보장해주는 건 아니다.
    *   **커버리지에 대한 강박관념을 버리고 의미 있는 테스트를 작성하는데 집중해야 한다.**
*   자동화된 단위 테스트는 개발자가 직접 작성해야 한다는 인식은 이미 널리 퍼져있지만, 어떤 테스트를 얼마나 많이 작성해야 하는가에 대한 인식은 여전히 부족
*   수확 체감
    *   커버리지가 100%에 근접할 수록 테스트를 더 작성해야 하는가에 대해서는 확신이 줄어듬
*   프로그래머 생산성에 영향을 주는 요소에는 무엇이 있고, 그 안에서 단위 테스트의 역할은 무엇일까?

## 1.2 테스트의 가치

*   중복도 많고 쓸데없이 복잡한 테스트 코드는 생산성을 떨어뜨리고 테스트의 긍정적 효과마저 앗아간다.
*   엉터리로 작성한 테스트 코드는 가독성만이 아니라 안정성과 신뢰성, 실행 속도에도 악영향을 준다.
*   테스트 실행 속도
    *   변경사항을 검증하고 확인하기위해 기다리는 시간에 직결
*   가독성
    *   가독성이 떨어지면 자연스레 분석이 더뎌지고 디버거를 사용해야하는 상황이 만들어진다.
    *   실수한 곳을 찾기 어려워 더 많은 결함이 만들어지고, 늘어난 결함은 디버깅 시간 증가로 이어진다.
*   테스트 결과의 정확성
    *   실수로 결함을 만들어도 테스트 스위트가 찾아줄 거라며 믿고 의지하고 싶다면 정확성이라도 반드시 보장되어야 한다.
*   가독성, 안정성, 신뢰성, 테스트 속도



### 1.2.2 설계 잠재력 곡선

*   테스트 잠재 가치를 전부 끌어내고 두 고지를 모두 정복하려면 다음처럼 하면 된다.
    1.  테스트 코드도 제품 코드 다루듯 하라. 믿고 의지할 수 있을 만큼 철저하게 리팩토링하고 높은 품질을 유지하라.
    2.  테스트 제품 코드가 목적과 쓰임새에 적합한 구조가 되게끔 이끌어 주는 설계 수단으로 활용하라

## 1.3 설계 수단으로써의 테스트

테스트는 전통적으로 두 가지 목적을 위한 품질 보증 수단

1.  코드를 작성하는 즉시 정확하게 구현했는지 검사
2.  그후 코드베이스가 커져도 계속 잘 동작하는지 지속해서 확인하는 것



테스트를 설계 수단으로 이용하기 시작하면 모든 것이 뒤바뀐다.

*   순서가 테스트, 코딩, 설계로 바뀐다.
*   테스트가 코딩보다 선행되고 설계로 마무리된다.
    *   마무리 설계 단계 -> 리팩토링



### 1.3.1 테스트 주도 개발

*   실패하는 테스트 없이는 코드를 작성하지 않는다.
*   긍정적 효과
    1.  프로젝트 진척도나 필요한 다른 컴포넌트, 클래스, 인터페이스가 갖춰져 있는지오 ㅏ상관없이 항시 명확한 사용 시나리오가 딸린 설계만 쥐어져 있게 된다.
        *   테스트 코드는 제품코드를 사용하는 고객의 입장이 되어 코드 한 줄 쓰기도 전에 설계가 올바로 되었는지 검증해준다.
    2.  테스트를 통과할 만큼만 코딩한다는 규칙을 잘 따라주면 설계를 간결하면서도 목적에 딱 맞도록 유지할 수 있다.
        *   but, 우발적 복잡성은 코드 품질을 떨어뜨리는 가장 악명 높은 적이자 개발자 생산성을 갉아먹는 주 요인이다.
        *   결함이나 빠진 기능을 명시하는 테스트, 테스트를 통과할 만큼의 코드만 작성한다는 규칙, 그리고 간결한 설계를 지향하는 철저한 리팩토링은 우발적 복잡성을 크게 줄여준다.

### 1.3.2 행위 주도 개발

*   생각의 초점을 테스트에서 행위로 옮기는 것이 대단한 발견임을 깨달은 후부터 나는 TDD를 BDD 혹은 행위 주도 개발이라 부르기 시작했다.

## 1.4 요약

1.  매우 높은 커버리지를 달성하여 테스트를 더 만들어봐야 얻을 게 거의 없다.
2.  단순 높은 커버리지가 아닌, 테스트의 품질까지 신경써야한다.

